function params = loadparfile3d(fname)
% params = LOADPARFILE3D(fname)
%
% Reads parameters from a Par_file of SPECFEM3D_Cartesian.
%
% DISCLAIMER: This is not the official way to read/write Par_file. I just
% go through comments and parameters in an instant of Par_file and
% read/write accordingly.
%
% INPUT:
% fname         name of the Par_file
%
% OUTPUT:
% params        parameters
%
% SEE ALSO:
% WRITEPARFILE, MAKEPARAMS
%
% Last modified by Sirawich Pipatprathanporn, 09/13/2024

names  = {};
values = {};
numvar = 0;

fid = fopen(fname, 'r');

line = fgetl(fid);
while ischar(line)
    % skip comments / headers
    while isempty(line) || strcmp(line(1), '#') || ~contains(line, '=')
        line = fgetl(fid);
        if ~ischar(line)
            break;
        end
    end
    if ~ischar(line)
        break;
    end
    
    numvar = numvar + 1;
    [name, value] = readgeneric(line);
    names{numvar} = name;
    values{numvar} = value;
    
    % read the next line
    line = fgetl(fid);
end

fclose(fid);

params = cell2struct(values, names, 2);
end

function [name, value] = readgeneric(line)
% list of variables with known data type
bool_var   = {'SAVE_FORWARD', ...
              'INVERSE_FWI_FULL_PROBLEM', ...
              'SUPPRESS_UTM_PROJECTION', ...
              'LTS_MODE', ...
              'USE_LDDRK', ...
              'INCREASE_CFL_FOR_LDDRK', ...
              'APPROXIMATE_OCEAN_LOAD', ...
              'TOPOGRAPHY', ...
              'ATTENUATION', ...
              'ANISOTROPY', ...
              'GRAVITY', ...
              'COMPUTE_FREQ_BAND_AUTOMATIC', ...
              'USE_OLSEN_ATTENUATION', ...
              'PML_CONDITIONS', ...
              'PML_INSTEAD_OF_FREE_SURFACE', ...
              'STACEY_ABSORBING_CONDITIONS', ...
              'STACEY_INSTEAD_OF_FREE_SURFACE', ...
              'BOTTOM_FREE_SURFACE', ...
              'UNDO_ATTENUATION_AND_OR_PML', ...
              'CREATE_SHAKEMAP', ...
              'MOVIE_SURFACE', ...
              'MOVIE_VOLUME', ...
              'SAVE_DISPLACEMENT', ...
              'MOVIE_VOLUME_STRESS', ...
              'USE_HIGHRES_FOR_MOVIES', ...
              'SAVE_MESH_FILES', ...
              'USE_SOURCES_RECEIVERS_Z', ...
              'USE_FORCE_POINT_SOURCE', ...
              'USE_RICKER_TIME_FUNCTION', ...
              'USE_EXTERNAL_SOURCE_FILE', ...
              'PRINT_SOURCE_TIME_FUNCTION', ...
              'USE_SOURCE_ENCODING', ...
              'SAVE_SEISMOGRAMS_DISPLACEMENT', ...
              'SAVE_SEISMOGRAMS_VELOCITY', ...
              'SAVE_SEISMOGRAMS_ACCELERATION', ...
              'SAVE_SEISMOGRAMS_PRESSURE', ...
              'SAVE_SEISMOGRAMS_STRAIN', ...
              'SAVE_SEISMOGRAMS_IN_ADJOINT_RUN', ...
              'USE_BINARY_FOR_SEISMOGRAMS', ...
              'SU_FORMAT', ...
              'ASDF_FORMAT', ...
              'HDF5_FORMAT', ...
              'WRITE_SEISMOGRAMS_BY_MAIN', ...
              'SAVE_ALL_SEISMOS_IN_ONE_FILE', ...
              'USE_TRICK_FOR_BETTER_PRESSURE', ...
              'OUTPUT_ENERGY', ...
              'READ_ADJSRC_ASDF', ...
              'ANISOTROPIC_KL', ...
              'SAVE_TRANSVERSE_KL', ...
              'ANISOTROPIC_VELOCITY_KL', ...
              'APPROXIMATE_HESS_KL', ...
              'SAVE_MOHO_MESH', ...
              'COUPLE_WITH_INJECTION_TECHNIQUE', ...
              'MESH_A_CHUNK_OF_THE_EARTH', ...
              'RECIPROCITY_AND_KH_INTEGRAL', ...
              'BROADCAST_SAME_MESH_AND_MODEL', ...
              'GPU_MODE', ...
              'ADIOS_ENABLED', ...
              'ADIOS_FOR_DATABASES', ...
              'ADIOS_FOR_MESH', ...
              'ADIOS_FOR_FORWARD_ARRAYS', ...
              'ADIOS_FOR_KERNELS', ...
              'ADIOS_FOR_UNDO_ATTENUATION', ...
              'HDF5_ENABLED', ...
              'HDF5_FOR_MOVIES'
              };
int_var    = {'SIMULATION_TYPE', ...
              'NOISE_TOMOGRAPHY', ...
              'UTM_PROJECTION_ZONE', ...
              'NPROC', ...
              'NSTEP', ...
              'PARTITIONING_TYPE', ...
              'NGNOD', ...
              'NT_DUMP_ATTENUATION', ...
              'MOVIE_TYPE', ...
              'NTSTEP_BETWEEN_FRAMES', ...
              'NTSTEP_BETWEEN_OUTPUT_INFO', ...
              'NTSTEP_BETWEEN_OUTPUT_SEISMOS', ...
              'NTSTEP_BETWEEN_OUTPUT_SAMPLE', ...
              'NTSTEP_BETWEEN_OUTPUT_ENERGY', ...
              'NTSTEP_BETWEEN_READ_ADJSRC', ...
              'INJECTION_TECHNIQUE_TYPE', ...
              'NUMBER_OF_SIMULTANEOUS_RUNS', ...
              'HDF5_IO_NODES'
              };
float_var  = {'DT', ...
              'RATIO_BY_WHICH_TO_INCREASE_IT', ...
              'ATTENUATION_f0_REFERENCE', ...
              'MIN_ATTENUATION_PERIOD', ...
              'MAX_ATTENUATION_PERIOD', ...
              'OLSEN_ATTENUATION_RATIO', ...
              'f0_FOR_PML', ...
              'HDUR_MOVIE'
              };
string_var = {'MODEL', ...
              'TOMOGRAPHY_PATH', ...
              'SEP_MODEL_DIRECTORY', ...
              'LOCAL_PATH', ...
              'TRACTION_PATH', ...
              'FKMODEL_FILE'
              };

name = sscanf(line, '%s', 1);

if any(strcmp(bool_var, name))
    value = readbool(line);
elseif any(strcmp(int_var, name))
    value = readint(line);
elseif any(strcmp(float_var, name))
    value = readfloat(line);
elseif any(strcmp(string_var, name))
    value = readstring(line);
else
    fprintf('unable to determine type of "%s" variable. Read as string\n', ...
        name);
    keyboard;
    value = readstring(line);
end
end

function value = readstring(line)
% find equal sign
where_start = strfind(line, '=');

% find # where the comment starts
where_end = strfind(line, '#');
if isempty(where_end)
    where_end = length(line) + 1;
end

% read the value
value = strip(sscanf(line((where_start+1):(where_end-1)), '%c'));
end

function value = readbool(line)
value = readstring(line);
if strcmp(value, '.true.')
    value = true;
elseif strcmp(value, '.false.')
    value = false;
else
    % do not know what to do
    error(strcat('ValueError: cannot read a boolean\n', ...
                 sprintf('line >> %s\n', line)));
end
end

function value = readint(line)
% find equal sign
where = strfind(line, '=');
% read the value
value = sscanf(line((where+1):end), '%d', 1);
end

function value =  readfloat(line)
% find equal sign
where = strfind(line, '=');
% change the exponent notation syntax from 'd' to 'e'
line = replace(line, 'd', 'e');
% read the value
value = sscanf(line((where+1):end), '%f', 1);
end